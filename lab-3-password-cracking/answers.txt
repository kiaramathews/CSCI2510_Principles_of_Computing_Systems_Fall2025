1.  As the answer to the first exercise, list your name.
        Kiara Mathews

2.  What four-letter password corresponds to the following target:
    \'`abccBcrPOxnLU`\'?
        "pass"
        
3.  What five-letter password corresponds to the following target:
    \'`xyxMB6gxuiBZg`\'?
        "ferry"

4.  The following hash does not correspond to any password, so your
    program will exhaust the entire search space without finding any
    match. Use the `time` command to measure how long your program takes
    to search the entire space of five-letter passwords. Hash
    \'`nomatchingpass`\'
        ./crack 1 5 nomatchingpass  52.06s user 0.20s system 97% cpu 53.441 total

5.  Re-run the previous experiment but with two threads, four threads,
    eight threads, thirteen threads, and twenty-six threads. Record how
    long each run takes.
        ./crack 2 5 nomatchingpass  0.06s user 0.00s system 150% cpu 0.043 total
        ./crack 4 5 nomatchingpass  0.01s user 0.00s system 140% cpu 0.012 total
        ./crack 8 5 nomatchingpass  0.00s user 0.01s system 84% cpu 0.013 total
        ./crack 13 5 nomatchingpass  0.02s user 0.01s system 186% cpu 0.013 total
        ./crack 26 5 nomatchingpass  0.01s user 0.01s system 141% cpu 0.010 total

6.  Calculate the *hash rate* your program gets as a result of using
    multiple threads. The hash rate is defined to be the number of
    hashes computed divided by the execution time. Do this for each of
    the two, four, eight, thirteen, and twenty-six threads.
        2 threads: 276,311,070
        4 threads: 990,114,667
        8 threads: 913,952,000 
        13 threads: 913,952,000
        26 threads: 1,188,137,600

7.  Interpret your results. Does your program run twice as fast with two
    threads? Does it run eight times faster with eight threads? How does
    this relate to the way you have written your program?
        Performance improves with more threads, but does not achieve perfect linear speedup. Overall, the efficiency decreases as 
        more threads are added because the overhead becomes more significant and relative to the actual work being done.

8.  What was the maximum hash rate you recorded?
        The maximum hash rate was 1,188,137,600, acheived with 26 threads

9.  Assuming each password only uses the 26 lowercase characters,
    compute the total number of hashes needed to exhaustively search the
    keyspace for keysizes of one through eight.
        Formula: 26^1 + 26^2 +...+ 26^8
        Keysize 1: 26
        Keysize 2: 26 + 676 = 702
        Keysize 3: 702 + 17,576 = 18,278
        Keysize 4: 18,278 + 456,976 = 475,254
        Keysize 5: 475,254 + 11,881,376 = 12,356,630
        Keysize 6: 12,356,630 + 308,915,776 = 321,272,406
        Keysize 7: 321,272,406 + 8,031,810,176 = 8,353,082,582
        Keysize 8: 8,353,082,582 + 208,827,064,576 = 217,180,147,158
    Total number for hashes: 217,180,147,158
        
10. Using the last two answers, estimate how long it should take to
    exhaust each keyspace at your maximum rate? Describe the benefit of
    increasing key length.
        8,353,082,582 / 1,188,137,600 = 7.03040 s
       217,180,147,158 / 1,188,137,600 = 182.79040 s

    Increaing the key rate improved the security because thet total number of possible
    passwaords grew. This shows that even when an attacker is fast with many threads,
    longer passwords are still much harder. 
        
11. Instead of just using lowercase characters, estimate how long it
    takes to exhaustively search a keyspace of size six when you are
    allowed to use lowercase and uppercase (52 characters), digits (62
    characters), and common keyboard symbols (93 characters). Use your
    maximum hash rate.
        26^6= 308,915,776  / 1,188,137,600 = 0.26s
        52^6= 19,770,609,664  / 1,188,137,600 = 16.64s
        62^6= 56,800,235,584  / 1,188,137,600 = 47.81s
        93^6= 646,990,183,449  / 1,188,137,600 = 544.54s

12. Describe any known bugs or ways that your submission deviates from
    the above specification.
        None
13. Indicate which, if any, extra credit exercises you have attempted.
-   **2% Extra Credit**: Crack the following five-letter password
    hashes:
    passwords found: 
    * `abA.g8pU2Iffo` = hk
    * `cdfnIXMyMCpPg` = iy
    * `efgC/gw8PDKhs` = dbf
    * `ghLneTdBMxJP.` = cbh
    * `ijSsXTgIC7QRU` = fcw
    * `klr7dT7cAODsk` = cys
    * `mn4iWfK0m76t6` = ti
    * `opjPsgpXaahxM` = edz
    * `qr6ncfvfqecME` = ql

-   **2% Extra Credit**: Explain why password salts are useful, even if
    they\'re not secret.
        Password salts are useful because they make sure that all identical passwords are hashed
        to different values. The prevent hackers from using precomputed tables because a separete 
        table would be needed for each salt possible. Salts also prevent attackers from identifying all users with
        that password to prevent large groups of cracking.
-   **2% Extra Credit**: Add a fourth paramter to your program which, if
    present, causes your program to search all uppercase and lowercase
    characters, plus numbers and symbols. *Hint: look at an ASCII table.
    What range of decimal encodings includes all of the above?*